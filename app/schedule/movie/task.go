package movie

import (
	"fmt"
	"github.com/PuerkitoBio/goquery"
	"github.com/corpix/uarand"
	"github.com/gin-gonic/gin"
	"github.com/goccy/go-json"
	"github.com/sirupsen/logrus"
	"github.com/spf13/viper"
	"io/ioutil"
	"net/http"
	"spider-bilibili/app/ippool"
	"spider-bilibili/app/tools"
	"strings"
	"sync"
	"time"
)

type PageInfo struct {
	Title string `json:"title"`
	Link  string `json:"link"`
}

func Run() {
	inter := viper.GetDuration("inter")
	ticker := time.NewTicker(inter)
	defer ticker.Stop()

	for range ticker.C {
		//getinfo()
	}
}
func Do() {
	//getinfo()
}

func GetLink() []string {
	//检查cookie是否有效
	for !tools.CheckCookieValidity() {
		tools.GetCookie()
	}

	fmt.Println("登录成功")

	proxyInfo := ippool.GetProxyInfo()
	if proxyInfo.IP == "" || proxyInfo.Client == nil {
		logrus.Error("没有获取到有效的代理IP或http.Client")
		return nil
	}
	//if !validateProxy(proxyInfo) {
	//	updateProxyInfo()
	//	proxyInfo = getProxyInfo()
	//}
	//fmt.Println("使用代理 IP 地址:", proxyInfo.IP)

	// 直接使用返回的 http.Client 发起请求
	request, err := http.NewRequest("GET", viper.GetString("bilibili_api.movie"), nil)
	if err != nil {
		logrus.Error("请求bilibili电影失败", err)
	}
	//获取一个随机的user-agent并添加到请求头
	//request.Header.Add("User-Agent", "uarand.GetRandom()")
	//添加请求头
	//使用一个随机的cookie并添加到请求头

	request.Header.Add("User-Agent", uarand.GetRandom())
	request.AddCookie(&http.Cookie{Name: "bili_jct", Value: viper.GetString("cookie.bili_jct")})
	request.AddCookie(&http.Cookie{Name: "DedeUserID", Value: viper.GetString("cookie.DedeUserID")})
	request.AddCookie(&http.Cookie{Name: "DedeUserID__ckMd5", Value: viper.GetString("cookie.DedeUserID__ckMd5")})
	request.AddCookie(&http.Cookie{Name: "SESSDATA", Value: viper.GetString("cookie.SESSDATA")})
	request.AddCookie(&http.Cookie{Name: "sid", Value: viper.GetString("cookie.sid")})
	response, err := proxyInfo.Client.Do(request)

	if err != nil {
		logrus.Error("请求bilibili电影失败", err)
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusOK {
		logrus.Error("请求bilibili电影失败，状态码：", response.StatusCode)
		return nil
	}
	//这里使用go语言标准库的ioutil.ReadAll函数读取response.body文件。
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		logrus.Error("bilibili电影:读取响应内容失败", err)
		return nil
	}
	var ret AutoGenerated
	_ = json.Unmarshal(body, &ret)
	var link []string
	for _, item := range ret.Data.List {
		url := item.Link
		link = append(link, url)
	}
	return link
}

func GetInfo(c *gin.Context) {
	//根据获取的url重新请求页面
	urls := GetLink()
	if urls == nil {
		c.JSON(http.StatusInternalServerError, tools.ECode{
			Code:    1,
			Message: "没有获取到电影链接",
		})
		return
	}
	proxy := ippool.GetProxyInfo()
	if proxy.IP == "" || proxy.Client == nil || !ippool.ValidateProxy(proxy) {
		ippool.UpdateProxyInfo()
		proxy = ippool.GetProxyInfo()
	}

	if proxy.IP == "" || proxy.Client == nil {
		logrus.Error("电影没有获取到有效的代理IP或http.Client")
		c.JSON(http.StatusInternalServerError, tools.ECode{
			Code:    1,
			Message: "电影没有获取到有效的代理IP或http.Client",
		})
		return
	}

	// 用于同步goroutine的WaitGroup
	var wg sync.WaitGroup
	// 用于存放解析结果的通道
	animeChan := make(chan Movie, len(urls))

	for _, url := range urls {
		wg.Add(1)
		go func(url string) {
			defer wg.Done()
			request, err := http.NewRequest("GET", url, nil)
			if err != nil {
				logrus.Error("电影:创建请求失败", err)
				return
			}
			//request.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36 Edg/125.0.0.0")
			//request.AddCookie(&http.Cookie{Name: "SESSDATA", Value: viper.GetString("cookie.SESSDATA")})
			//request.AddCookie(&http.Cookie{Name: "bili_jct", Value: viper.GetString("cookie.bili_jct")})
			//request.AddCookie(&http.Cookie{Name: "DedeUserID", Value: viper.GetString("cookie.DedeUserID")})
			//request.AddCookie(&http.Cookie{Name: "DedeUserID__ckMd5", Value: viper.GetString("cookie.DedeUserID__ckMd5")})
			//request.AddCookie(&http.Cookie{Name: "sid", Value: viper.GetString("cookie.sid")})

			response, err := ippool.ProxyInfo.Client.Do(request)
			fmt.Println("request", request)
			fmt.Println("response", response)

			if err != nil {
				logrus.Error("电影：http请求失败", err)
			}
			defer response.Body.Close()

			if response.StatusCode != http.StatusOK {
				logrus.Error("电影：http请求失败，状态码：", response.StatusCode)
				return
			}
			body, err := ioutil.ReadAll(response.Body)
			if err != nil {
				logrus.Error("电影：读取响应到body失败", err)
				return
			}
			doc, err := goquery.NewDocumentFromReader(strings.NewReader(string(body)))
			if err != nil {
				logrus.Error("将html字符串加载到goquery失败：", err)
			}
			doc.Find("#__next > div.home-container > div > div.plp-l.sticky > div > div.mediainfo_mediaInfoWrap__nCwhA > div").Each(func(i int, s *goquery.Selection) {
				title := strings.TrimSpace(s.Find("a.mediainfo_mediaTitle__Zyiqh").Text())
				url, _ := s.Find("a.mediainfo_mediaTitle__Zyiqh").Attr("href")
				total := s.Find("div.mediainfo_mediaDesc__jjRiB").Eq(0).Text()
				//re := regexp.MustCompile(`(\d+\.\d+万).*?(\d+\.\d+万).*?(\d+\.\d+万系列追番)`)

				parts := strings.Split(total, "·")
				total_play := strings.Split(parts[0], "播放")[0]
				total_danmu := strings.Split(parts[1], "弹幕")[0]
				total_people := strings.Split(parts[2], "系列追番")[0]
				//matches := re.FindStringSubmatch(total)
				//total_play := matches[1]
				//total_danmu := matches[2]
				//total_people := matches[3]

				//total_play := s.Find("div.mediainfo_mediaDesc__jjRiB").Eq(0).Text()
				//total_danmu := s.Find("div.mediainfo_mediaDesc__jjRiB").Eq(1).Text()
				//total_people := s.Find("div.mediainfo_mediaDesc__jjRiB").Eq(2).Text()
				style := s.Find("div.mediainfo_mediaDesc__jjRiB span").Eq(0).Text()
				play_time := s.Find("div.mediainfo_mediaDesc__jjRiB span").Eq(1).Text()
				status := s.Find("div.mediainfo_mediaDesc__jjRiB span").Eq(2).Text()
				avator := s.Find("div.mediainfo_mediaDesc__jjRiB[title]").Text()
				desc := s.Find("#__next > div.home-container > div > div.plp-l.sticky > div > div.mediainfo_mediaInfoWrap__nCwhA > div > a.mediainfo_media_desc_section__Vkt2t > div > p").Text()

				a := Movie{
					Title:       title,
					URL:         url,
					Updatedver:  time.Now().Unix(),
					TotalPlay:   total_play,
					TotalDanmu:  total_danmu,
					TotalPeople: total_people,
					Style:       style,
					PlayTime:    play_time,
					Status:      status,
					Avator:      avator,
					Desc:        desc,
					CreatedTime: time.Now(),
					UpdatedTime: time.Now(),
				}
				animeChan <- a
			})
		}(url)
	}
	wg.Wait()
	close(animeChan)

	var movie []Movie
	for a := range animeChan {
		movie = append(movie, a)
	}
	c.JSON(http.StatusOK, tools.ECode{
		Code:    0,
		Message: "",
		Data:    movie,
	})
}
